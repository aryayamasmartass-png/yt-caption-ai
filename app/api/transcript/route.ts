import { type NextRequest, NextResponse } from "next/server"
import { Innertube } from "youtubei.js"

function extractVideoId(url: string): string | null {
  // Handle youtube.com/watch?v= format
  const watchMatch = url.match(/[?&]v=([^&]+)/)
  if (watchMatch) return watchMatch[1]

  // Handle youtu.be/ format
  const shortMatch = url.match(/youtu\.be\/([^?&]+)/)
  if (shortMatch) return shortMatch[1]

  // Handle youtube.com/embed/ format
  const embedMatch = url.match(/youtube\.com\/embed\/([^?&]+)/)
  if (embedMatch) return embedMatch[1]

  // Handle youtube.com/v/ format
  const vMatch = url.match(/youtube\.com\/v\/([^?&]+)/)
  if (vMatch) return vMatch[1]

  // Handle youtube.com/shorts/ format
  const shortsMatch = url.match(/youtube\.com\/shorts\/([^?&]+)/)
  if (shortsMatch) return shortsMatch[1]

  return null
}

async function getVideoTitle(videoId: string): Promise<string> {
  try {
    const response = await fetch(
      `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`,
    )
    if (response.ok) {
      const data = await response.json()
      return data.title || "YouTube Video"
    }
  } catch {
    // Ignore errors, return default title
  }
  return "YouTube Video"
}

async function fetchTranscriptFromYouTube(videoId: string): Promise<string> {
  try {
    const youtube = await Innertube.create()
    const info = await youtube.getInfo(videoId)

    const transcriptData = await info.getTranscript()

    if (!transcriptData || !transcriptData.transcript || !transcriptData.transcript.content) {
      throw new Error("NO_CAPTIONS")
    }

    const segments = transcriptData.transcript.content.body?.initial_segments

    if (!segments || segments.length === 0) {
      throw new Error("NO_CAPTIONS")
    }

    const transcriptText = segments
      .map((segment: any) => segment.snippet?.text || "")
      .filter((text: string) => text.trim() !== "")
      .join(" ")

    if (!transcriptText || transcriptText.trim() === "") {
      throw new Error("NO_CAPTIONS")
    }

    return transcriptText
  } catch (error) {
    // Suppress non-critical youtubei.js parser errors
    if (error instanceof Error && error.message.includes("Type mismatch")) {
      // Parser error but transcript might still be available, ignore it
      console.warn("YouTubei.js parser warning (non-critical):", error.message.split('\n')[0])
    } else {
      console.error("YouTube Transcript Error:", error)
    }
    if (error instanceof Error && error.message === "NO_CAPTIONS") {
      throw error
    }
    throw new Error("NO_CAPTIONS")
  }
}

async function generateTranscriptWithGemini(videoId: string, apiKey: string): Promise<string> {
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`

  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: `Please watch this YouTube video and provide a complete, accurate transcript of all spoken words. Format it as clean, readable text without timestamps. Video URL: ${videoUrl}`,
              },
            ],
          },
        ],
        generationConfig: {
          temperature: 0.1,
          maxOutputTokens: 8192,
        },
      }),
    },
  )

  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.error?.message || "Failed to generate transcript with Gemini")
  }

  const data = await response.json()
  const transcript = data.candidates?.[0]?.content?.parts?.[0]?.text

  if (!transcript) {
    throw new Error("No transcript generated by Gemini")
  }

  return transcript
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { url, useGemini, geminiApiKey } = body

    if (!url || typeof url !== "string") {
      return NextResponse.json({ error: "Please provide a valid YouTube URL" }, { status: 400 })
    }

    const videoId = extractVideoId(url)

    if (!videoId) {
      return NextResponse.json(
        { error: "Invalid YouTube URL. Please use a youtube.com or youtu.be link." },
        { status: 400 },
      )
    }

    const title = await getVideoTitle(videoId)

    // If using Gemini, generate transcript with AI
    if (useGemini) {
      if (!geminiApiKey) {
        return NextResponse.json({ error: "Gemini API key is required for AI-generated transcripts" }, { status: 400 })
      }

      try {
        const transcript = await generateTranscriptWithGemini(videoId, geminiApiKey)
        return NextResponse.json({ transcript, title, source: "gemini" })
      } catch (error) {
        return NextResponse.json(
          {
            error: error instanceof Error ? error.message : "Failed to generate transcript with Gemini",
          },
          { status: 500 },
        )
      }
    }

    try {
      const transcript = await fetchTranscriptFromYouTube(videoId)
      return NextResponse.json({ transcript, title, source: "youtube" })
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : ""

      if (errorMessage === "NO_CAPTIONS") {
        return NextResponse.json(
          {
            error: "Captions are disabled or unavailable for this video. Try using Gemini AI to generate a transcript.",
          },
          { status: 400 },
        )
      }

      return NextResponse.json(
        {
          error: "Failed to fetch transcript. The video may not have captions available.",
        },
        { status: 500 },
      )
    }
  } catch (error) {
    console.error("Transcript API error:", error)
    return NextResponse.json({ error: "An unexpected error occurred. Please try again." }, { status: 500 })
  }
}
